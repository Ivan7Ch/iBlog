<!DOCTYPE html>
<html lang="en">

<head>
    <title>4: Групи ти Семафори</title>

    <!-- Meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Blog Template">
    <meta name="author" content="Xiaoying Riley at 3rd Wave Media">
    <link rel="shortcut icon" href="favicon.ico">

    <!-- FontAwesome JS-->
    <script defer src="https://use.fontawesome.com/releases/v5.7.1/js/all.js" integrity="sha384-eVEQC9zshBn0rFj4+TU78eNA19HMNigMviK/PU/FFjLXqa/GKPgX58rvt5Z8PLs7" crossorigin="anonymous"></script>

    <!-- Plugin CSS -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/styles/monokai-sublime.min.css">

    <!-- Theme CSS -->
    <link id="theme-style" rel="stylesheet" href="assets/css/theme-1.css">


</head>

<body>

    <header class="header text-center">
        <h2 class="blog-name pt-lg-4 mb-0"><a href="index.html">Зміст</a></h2>

        <nav class="navbar navbar-expand-lg navbar-light">

            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navigation" aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
			<span class="navbar-toggler-icon"></span>
			</button>

            <div id="navigation" class="collapse navbar-collapse flex-column">
                <div class="profile-section pt-3 pt-lg-0">

                    <ul class="navbar-nav flex-column text-left">
                        <li class="nav-item">
                            <a class="nav-link" href="chapter1.html"></i>1: Вступ<span class="sr-only">(current)</span></a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="chapter2.html"></i>2: GCD & Операції.</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="chapter3.html"></i>3: Черги & Потоки.</a>
                        </li>
                        <li class="nav-item active">
                            <a class="nav-link" href="chapter4.html"></i>4: Групи ти Семафори.</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="chapter5.html"></i>5: Проблеми багатопотоковості</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="chapter6.html"></i>6: Операції</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="chapter7.html"></i>7: Черги операцій</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="chapter8.html"></i>8: Асинхронні операції</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="chapter9.html"></i>9: Залежності між операціями</a>
                        </li>

                        <li class="nav-item">
                            <a class="nav-link" href="chapter10.html"></i>10: Скасування операцій</a>
                        </li>
                    </ul>
                    <!--//social-list-->
                </div>
                <!--//profile-section-->


                <div class="my-2 my-md-3">
                    <a class=" btn btn-primary " href="index.html ">Home</a>
                </div>
            </div>
        </nav>
    </header>

    <div class="main-wrapper">

        <article class="blog-post px-3 py-5 p-md-5">
            <div class="container">
                <header class="blog-post-header">
                    <h1 class="title mb-2">Глава 4: Групи ти Семафори</h1>
                    <div class="meta mb-3"><span class="date">Chapter 4: Groups & Semaphores</span><span class="time">18 min read</span></div>
                </header>
                <div class="blog-post-body">
                    <br>
                    <p>Іноді замість того, щоб просто поміщати завдання в чергу, вам потрібно обробити групу завдань. Всі вони не повинні запускатися одночасно, але вам потрібно знати, коли вони закінчились. Для такого сценарію Apple пропонує dispatch groups.</p>
                    <br>
                    <h2>DispatchGroup</h2>
                    <p>Клас з відповідним ім'ям <b>DispatchGroup</b> - інструмент, який варто використовувати, коли вам потрібно відстежувати виконання групи завдань.</p>
                    <p>Для початку потрібно провести ініціалізацію DispatchGroup. Якщо у вас є задача і ви хочете відстежувати її як частину групи, ви можете передати її в групу в якості аргументу асинхронного методу (async):
                    </p>
                    <img width="487" src="assets/images/cs13.png" style="margin-bottom: 10px;" alt="">
                    <p>Як видно з наведеного вище прикладу коду, групи не прив'язані до однієї dispatch queue. Ви можете використовувати одну групу, але відправляти завдання в кілька різних черг, в залежності від пріоритету задачі, яку необхідно виконати.
                        DispatchGroups надають метод <b>notify(queue :)</b>, який ви можете використовувати, щоб отримувати повідомлення, як тільки завершиться кожне з відправлених завдань.</p>
                    <p style="background-color:rgb(224, 224, 224); padding: 15px; "><i><b>Note:</b> Повідомлення саме по собі є асинхронним, тому після виклику повідомлення можна відправити більше завдань групі, якщо раніше надіслані завдання ще не завершені.
                        </i></p>
                    <p>Ви можете відмітити, що метод <b>notify</b> приймає чергу в якості параметра. Коли всі завдання завершені, надане вами замикання буде виконано у зазначеній черзі. Показаний виклик повідомлення є найпоширенішою версією виклику, але
                        є і інші версії, які, наприклад, дозволяють вам вказати якість обслуговування QoS.
                    </p>
                    <br>
                    <h3>Синхронне очікування</h3>
                    <div class="meta mb-3"><span class="date">Synchronous waiting</span></div>
                    <p>Замість методу <b>notify</b> ви можете використовувати метод <b>wait</b> для групи. Це синхронний метод, який блокує поточну чергу до завершення всіх завдань. Він приймає необов'язковий параметр, який вказує, як довго чекати завершення
                        завдань. Якщо він не вказаний, то за замовчуванням час очікування нескінченний:
                    </p>
                    <img width="432" src="assets/images/cs14.png" style="margin-bottom: 10px;" alt="">
                    <br>
                    <p style="background-color:rgb(224, 224, 224); padding: 15px; "><i><b>Note:</b> Пам'ятайте, wait блокує поточний потік; ніколи не викликайте wait в головній (main) черзі.
                    </i></p>
                    <p>У наведеному вище прикладі ви даєте завданням до 60 секунд, щоб вони змогли завершити свою роботу до того, як виконається блок wait.
                    </p>
                    <p>Важливо пам’ятати, що завдання, як і раніше будуть виконуватися навіть після виклику блоку wait. Щоб переконатися в цьому на практиці, перейдіть до початкових проектів в прикріплених матеріалах до цієї глави і відкрийте playground
                        під назвою <b>DispatchGroup.playground</b>.
                    </p>
                    <p>В playground додано два завдання в групу: одне з них займає 10 секунд (завдання 1), а інше має дві секунди на виконання:</p>

                    <img width="463" src="assets/images/cs15.png" style="margin-bottom: 10px;" alt="">
                    <p>Потім група синхронно очікує завершення:
                    </p>
                    <img width="423" src="assets/images/cs16.png" style="margin-bottom: 10px;" alt="">
                    <p>Запустіть playground і подивіться на вивід з правого боку вікна Xcode. Ви повинні побачити повідомлення про те, що завдання 1 і 2 запущені. Через дві секунди ви побачите повідомлення про те, що завдання 2 виконано, а через три секунди
                        - повідомлення «<b>I got tired of waiting</b>».
                    </p>
                    <p>З прикладу видно, що завдання 2 заморожено тільки на дві секунди, і воно може бути виконано, тому, що група буде очікувати 5 секунд, але цього недостатньо для завершення завдання 1, тому буде надруковано повідомлення про закінчення
                        часу очікування.
                    </p>
                    <p>Однак, якщо ви почекаєте ще п'ять секунд - ви побачите повідомлення про завершення завдання 1.
                    </p>
                    <p>На цьому етапі виклик методу синхронного очікування, подібного до цього, повинен викликати у вас <b>code smell</b>, потенційно вказуючи на інші проблеми у вашій архітектурі. Звичайно, набагато простіше реалізувати синхронний підхід,
                        але причина, по якій ви читаєте цю книгу, полягає в тому, щоб дізнатися, як змусити ваш додаток працювати максимально швидко. Постійне звертання і запитування чи потік вже все закінчив - не найкраще використання системних ресурсів.
                    </p>

                    <br>
                    <h2>Інкапсуляція асинхронних методів</h2>
                    <div class="meta mb-3"><span class="date">Wrapping asynchronous methods</span></div>
                    <p><b>Dispatch queue</b> знає, як працювати з <b>dispatch groups</b>, і відповідає за те, щоб повідомити системі, що завдання виконано. Чому це важливо? Тому що, якщо ви викликаєте асинхронний метод всередині вашого замикання, замикання
                        завершиться до завершення внутрішнього асинхронного методу.</p>
                    <p>Ви повинні якось вказати задачі, що вона не виконана, поки її підзадачі не будуть завершені. В такому випадку ви можете викликати методи входу і виходу в DispatchGroup. Ці методи можна вважати звичайним лічильником задач, що виконуються.
                        Кожен раз, коли ви запускаєте нову задачу, лічильник збільшується на 1. Коли вона завершується, лічильник зменшується на 1:</p>

                    <img width="391" src="assets/images/cs17.png" style="margin-bottom: 10px;" alt="">

                    <p>Викликаючи <b>group.enter()</b>, ви повідомили групу про те, що виконується ще один блок коду, який слід враховувати в загальному стані завершення групи. Ви, звичайно, повинні не забути і про відповідний виклик <b>group.leave()</b>,
                        інакше ви ніколи не отримаєте сигнал про завершення. Оскільки ви повинні викликати метод <b>leave</b> навіть в умовах помилки, вам потрібно буде використати оператор <b>defer</b>, як показано вище, щоб незалежно від того, в якому
                        стані буде відбуватися вихід із замикання, виконувався код <b>group.leave()</b>.
                    </p>
                    <p>У простому випадку, схожому на попередній приклад коду, ви можете безпосередньо викликати пари введення / виведення. Якщо ви збираєтеся часто використовувати <b>someAsyncMethod</b> з групами, вам слід інкапсулювати його в метод, щоб
                        не забути зробити необхідні виклики:
                    </p>

                    <img width="559" src="assets/images/cs18.png" style="margin-bottom: 10px;" alt="">
                    <p>Метод не надає нічого особливого, окрім 100% впевненості в тому, що методи <b>enter</b> та <b>leave</b> будуть правильно оброблені.
                    </p>
                    <br>
                    <h3>Завантаження зображень</h3>
                    <div class="meta mb-3"><span class="date">Downloading images</span></div>

                    <p>Завантаження даних по мережі завжди має бути асинхронною операцією. Технічний редактор цієї книги отримав завдання, яке вимагало від нього завантаження аватарів всіх гравців. Dispatch group є ідеальним рішенням для цього завдання.
                    </p>
                    <p>Будь ласка, перейдіть у playground під назвою <b>Images.playground</b> в прикріпленій папці до цієї глави. Ваше завдання - асинхронно завантажити кожне зображення з наданого масиву імен. По завершенні ви повинні показати хоча б одне
                        із зображень.</p>
                    <p>Зрозуміло, що для створення URL-адрес вам доведеться перебирати зображення, тому почніть з цього:</p>

                    <img width="574" src="assets/images/cs19.png" style="margin-bottom: 10px;" alt="">
                    <p>Тепер, коли у вас є валідний URL, викличте метод <b>dataTask</b> класу <b>URLSession</b>. Він вже є асинхронним, тому вам потрібно обробити вхід і вихід групи:</p>
                    <img width="622" src="assets/images/cs20.png" style="margin-bottom: 10px;" alt="">
                    <p>Як завжди, з асинхронним кодом оператор <b>defer</b> стане вам в пригоді. Тепер, коли ви асинхронно запустили завдання, незалежно від того, як воно завершиться, ви повинні повідомити групу, що завдання виконане. Якщо ви цього не зробите,
                        додаток буде знаходитися в очікуванні завершення:</p>
                    <img width="281" src="assets/images/cs21.png" style="margin-bottom: 10px;" alt="">
                    <p>Після цього потрібно просто перетворити зображення і додати його в масив:</p>
                    <img width="661" src="assets/images/cs22.png" style="margin-bottom: 10px;" alt="">
                    <p>Використовуйте <b>callback</b> метод <b>notify(queue :)</b>, щоб отримувати інформацію про завершення всіх завантажень зображень. Додайте цей код після циклу for:</p>
                    <img width="384" src="assets/images/cs23.png" style="margin-bottom: 10px;" alt="">
                    <p>Якщо ви зараз запустите playground, то побачите на бічній панелі, як запускається кожне завдання, чи відбувається завантаження зображень.</p>
                    <br>
                    <h3>Семафори</h3>
                    <div class="meta mb-3"><span class="date">Semaphores</span></div>

                    <p>Існують випадки, коли вам потрібно контролювати, скільки потоків мають доступ до ресурсу. Ви вже знаєте як обмежити доступ до ресурсу для одного потоку, але бувають випадки, коли ви можете дозволити використовувати ресурси одночасно
                        всім потокам, при цьому зберігаючи над ними всіма контроль.</p>
                    <p>Наприклад, якщо ви завантажуєте дані з мережі, ви можете обмежити кількість завантажень одночасно. Для цього ви будете використовувати черги і групи, щоб була можливість дізнатися, коли всі завантаження завершені. Наприклад, ви хочете
                        дозволити тільки чотири завантаження одночасно, тому що ви знаєте, що завантажені дані досить великі і вимагають значних ресурсів.</p>
                    <p>Саме в такому варіанті вам підійде <b>DispatchSemaphore</b>. Перед будь-яким доступом до ресурсу вам потрібно викликати синхронний метод <b>wait</b>, і ваш потік призупинить своє виконання допоки ресурс знову не стане доступним. Якщо
                        ресурс не зайнятий, то ви одразу отримаєте до нього доступ.</p>
                    <p>При створенні <b>семафора</b>(semaphore) ви вказуєте, скільки дозволено одночасного доступу до ресурсу. Якщо ви хочете дозволити чотири завантаження по мережі одночасно - введіть 4. Якщо вам потрібно заблокувати ресурс для монопольного
                        доступу, просто вкажіть 1.</p>
                    <p>Відкрийте playground під назвою <b>Semaphores.playground</b>, і ви знайдете простий шаблонний код для настройки групи і черги. Після рядка, який ініціює чергу, створіть семафор, який дозволяє чотири одночасних доступи до ресурсу:</p>

                    <img width="376" src="assets/images/cs24.png" style="margin-bottom: 10px;" alt="">
                    <p>Відразу після створення семафора виконайте цикл, який буде використовуватися для запуску 10 мережевих завантажень:</p>
                    <img width="281" src="assets/images/cs25.png" style="margin-bottom: 10px;" alt="">
                    <p>Тепер в кожному потоці вам потрібно запросити дозвіл на використання ресурсу. Щоб змоделювати завантаження по мережі, ви можете просто призупинити потік на три секунди. Вставте цей код всередині асинхронного блоку:</p>
                    <img width="289" src="assets/images/cs26.png" style="margin-bottom: 10px;" alt="">

                    <p>Тепер ви повинні бути впевнені, що виклик <b>leave</b> в групі виконається, тому вам обов'язково потрібно повідомити, коли ви закінчите використовувати ресурс. Для цього вам знадобиться використати блок <b>defer</b>.</p>
                    <p>Якщо ви запустите playground, ви повинні побачити, що відбувається чотири завантаження, потім через три секунди - ще чотири і через наступні три секунди вже два останніх завантаження будуть завершені.
                    </p>
                    <p>Це корисний приклад, щоб продемонструвати як семафори виконують свою роботу з обмеження доступу. Проте, вам насправді потрібно щось скачати!</p>
                    <p>Видаліть все у playground після створення змінної семафора, а потім скопіюйте код з <b>Images.playground</b>, починаючи з оператора <b>let base</b>, і вставте його відразу після створення семафора. Ресурс, яким ви намагаєтеся керувати
                        - це мережа, тому ви можете дозволити створення URL-адреси в циклі for, але перед входом в групу вам потрібно дочекатися доступного семафора, тому додайте виклик семафора перед <b>group.enter()</b>:</p>

                    <img width="226" src="assets/images/cs27.png" style="margin-bottom: 10px;" alt="">
                    <p>Ви повинні використовувати обидва елементи, тому що семафор контролює доступ до ресурсу, а з допомогою групи ви можете відстежувати завершення. Також змініть оператор defer для обробки випуску семафора:
                    </p>
                    <img width="209" src="assets/images/cs28.png" style="margin-bottom: 10px;" alt="">
                    <p>Порядок рядків не має значення. Оновіть DispatchSemaphore value щоб отримати 2 замість 4, а потім запустіть playground. Цього разу ви повинні побачити, що він працює, як і раніше, тільки повільніше, через обмеження тільки двох завантажень,
                        що відбуваються одночасно.</p>
                    <img width="100%" src="assets/images/example2.png" style="margin-bottom: 15px;" alt="">
                    <br>
                    <h3>Який наступний крок?</h3>
                    <p>Змініть різні значення в playground, щоб переконатися, що ви правильно розумієте, як працюють групи і семафори.</p>
                    <p>Чи можете ви пригадати випадки в ваших попередніх або поточних додатках, в яких ви могли б застосувати групи чи семафори? Не турбуйтеся, якщо ви не можете придумати варіант використання семафорів. Це складна тема, яка рідко зустрічається
                        в повсякденному програмуванні, але варто знати, що такі інструменти існують.</p>
                    <p>Тепер, коли ви побачили, наскільки корисним є паралелізм з GCD, прийшов час поговорити про деякі негативні аспекти.</p>

                </div>
                <nav class=" blog-nav nav nav-justified my-5 ">
                    <a class="nav-link-prev nav-item nav-link rounded-left " href="chapter3.html ">Previous<i class="arrow-prev fas fa-long-arrow-alt-left "></i></a>
                    <a class="nav-link-next nav-item nav-link rounded-right " href="chapter5.html">Next<i class="arrow-next fas fa-long-arrow-alt-right "></i></a>
                </nav>
            </div>
            <!--//container-->
        </article>


        <footer class="footer text-center py-2 theme-bg-dark ">

        </footer>

    </div>
    <!--//main-wrapper-->


    <!-- Javascript -->
    <script src="assets/plugins/popper.min.js "></script>
    <script src="assets/plugins/bootstrap/js/bootstrap.min.js "></script>

    <!-- Custom JS -->
    <script src="assets/js/blog.js "></script>



</body>

</html>




<!--
    <p style="background-color:rgb(224, 224, 224); padding: 15px; "><i><b>Note:</b> </i></p>
    <img width="100%" src="assets/images/cs12.png" alt="">
-->
